<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tgstation-server: Server Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tgstation-server<span id="projectnumber">&#160;6.17.0</span>
   </div>
   <div id="projectbrief">The /tg/station 13 server suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Server Architecture</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#arch_intro">Introduction</a></li>
<li class="level1"><a href="#arch_hwatchdog">Host Watchdog</a></li>
<li class="level1"><a href="#arch_main">Main Server</a><ul><li class="level2"><a href="#arch_setup">Server Initialization</a><ul><li class="level3"><a href="#arch_instinit">Instance Manager Initialization</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#arch_db">Database and Context</a></li>
<li class="level1"><a href="#arch_controllers">Controllers</a></li>
<li class="level1"><a href="#arch_security">Security</a></li>
<li class="level1"><a href="#arch_jobs">Jobs</a></li>
<li class="level1"><a href="#arch_instance">Instances</a><ul><li class="level2"><a href="#arch_ifactory">Instance Factory</a></li>
</ul>
</li>
<li class="level1"><a href="#arch_repository">Repository Manager</a></li>
<li class="level1"><a href="#arch_byond">Byond</a></li>
<li class="level1"><a href="#arch_deployment">Compiler and Deployment</a></li>
<li class="level1"><a href="#arch_chat">Chat Bot System</a></li>
<li class="level1"><a href="#arch_static">Static File Management</a></li>
<li class="level1"><a href="#arch_watchdog">Watchdog</a><ul><li class="level2"><a href="#arch_wd_launch">Launch</a></li>
<li class="level2"><a href="#arch_wd_monitor">The Monitor</a><ul><li class="level3"><a href="#mar_activecrash">Active Server Crashed/Exited</a></li>
<li class="level3"><a href="#mar_inactivecrash">Inactive Server Crashed/Exited</a></li>
<li class="level3"><a href="#mar_activereboot">Active Server Rebooted</a></li>
<li class="level3"><a href="#mar_inactivereboot">Inactive Server Rebooted</a></li>
<li class="level3"><a href="#mar_setting">New Dmb Available or Launch Settings Changed</a></li>
</ul>
</li>
<li class="level2"><a href="#arch_reattach">Reattaching</a></li>
<li class="level2"><a href="#arch_comms">Communication</a></li>
</ul>
</li>
<li class="level1"><a href="#arch_update">Host Update Process</a></li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="ArchitectureOverview.png" alt=""/>
<div class="caption">
Architecture Overview</div></div>
<h1><a class="anchor" id="arch_intro"></a>
Introduction</h1>
<p>This is meant to be a brief overview of the TGS architecture to give new coders direction on where to code and the curious some insight to their questions. Given that this document is seperate from the authorative code it may fall out of date. For clairity, please contact project maintainers.</p>
<h1><a class="anchor" id="arch_hwatchdog"></a>
Host Watchdog</h1>
<p>The host watchdog process monitors the actual server application. It exists mainly to facilitate the live update system built into it and also serves as a restart mechanism if requested. This component is generally not present in active development scenarios due to debugging overhead.</p>
<p>This consists of two parts a runner and the watchdog library. The library is the <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_watchdog.html">Tgstation.Server.Host.Watchdog</a> project and the runners are the <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_console.html">Tgstation.Server.Host.Console</a> .NET Core project and the <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_service.html">Tgstation.Server.Host.Service</a> .NET Framework Windows service project</p>
<h1><a class="anchor" id="arch_main"></a>
Main Server</h1>
<p>This is a second process spawned by the Host Watchdog which facilitates the vast majority of the code. This is the <a class="el" href="namespace_tgstation_1_1_server_1_1_host.html">Tgstation.Server.Host</a> project which is fundamentally an ASP.NET Core MVC web application.</p>
<h2><a class="anchor" id="arch_setup"></a>
Server Initialization</h2>
<p>The server's entrypoint is in the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_program.html">Tgstation.Server.Host.Program</a> class. This class mainly determines if the Host watchdog is present and creates and runs the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_server.html">Tgstation.Server.Host.Server</a> class. That class then builds an ASP.NET Core web host using the Tgstation.Server.Host.Core.Application class.</p>
<p>The Tgstation.Server.Host.Core.Application class has two methods called by the framework. First the Tgstation.Server.Host.Core.Application.ConfigureServices method sets up dependency injection of interfaces for Controllers, the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_database_1_1_database_context.html">Tgstation.Server.Host.Database.DatabaseContext</a>, and the component factories of the server. The framework handles constructing these things once the application starts. Configuration is loaded from the appropriate appsettings.yml into the <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_configuration.html">Tgstation.Server.Host.Configuration</a> classes for injection as well. Then Tgstation.Server.Host.Core.Application.Configure method is run which sets up the web request pipeline which currently has the following stack of handlers:</p>
<ul>
<li>Catch any exceptions and respond with 500 and detailed HTML error page</li>
<li>Respond with 503 if the application is still starting or shutting down</li>
<li>Authenticate the JWT in Authentication header if present and run <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_controllers_1_1_api_controller.html">Tgstation.Server.Host.Controllers.ApiController</a> on success</li>
<li>Catch database exceptions and convert to 409 responses with the exception's Tgstation.Server.Api.Models.ErrorMessage</li>
<li>Check <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_controllers.html">Tgstation.Server.Host.Controllers</a> for correct controller and run the action and use it's response.<ul>
<li>If not properly authenticated beforehand and action has a Tgstation.Server.Host.Controllers.TgsAuthorizeAttribute return 401</li>
<li>If not properly authorized beforehand according to the parameters of the action's Tgstation.Server.Host.Controllers.TgsAuthorizeAttribute (if present) return 403</li>
<li>If requested action does not exist return 404</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="arch_instinit"></a>
Instance Manager Initialization</h3>
<p>Once the web host starts, the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_components_1_1_instance_manager.html#aa2bcc92fca46ad404800304ce4bdd781">Tgstation.Server.Host.Components.InstanceManager.StartAsync</a> function is called (due to being registered as a <a class="el" href="class_i_hosted_service.html">IHostedService</a> in Tgstation.Server.Host.Core.Application) this is the only StartAsync implementation that should be called by the framework, others should be called from this to maintain a cohesive initialization order.</p>
<p>The first thing this function does is call Tgstation.Server.Host.Database.DatabaseContext.Initialize which ensures the database is migrated, seeded, and ready to go. Then the Tgstation.Server.Host.Core.JobManager is started, which cleans up any jobs that are considered "still running" in the database. Finally all instances configured to be online are created in parallel (See <a class="el" href="architecture.html#arch_instance">Instances</a> for onlining process) and the Tgstation.Server.Host.Core.Application is signalled to stop blocking requests with 503 responses before they are processed.</p>
<h1><a class="anchor" id="arch_db"></a>
Database and Context</h1>
<p>The database is exposed as a series of DbSet&lt;T&gt; objects through <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_database_1_1_i_database_context.html">Tgstation.Server.Host.Database.IDatabaseContext</a> . Queries are performed via async LINQ expressions. Inserts, updates, and deletes are done via modifiying the DbSet&lt;T&gt;s and then calling <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_database_1_1_i_database_context.html#a74e123c6393ad813f997c882a22b228e">Tgstation.Server.Host.Database.IDatabaseContext.Save</a> . Do some reading on Entity Framework Core for a deeper understanding.</p>
<h1><a class="anchor" id="arch_controllers"></a>
Controllers</h1>
<p>The webserver operates in an MVC style. All requests are routed through the <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_controllers.html">Tgstation.Server.Host.Controllers</a> . If a route doesn't exist as an action in a controller, a 404 response will be returned. Controllers interact with components via injecting the <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_i_instance_manager.html">Tgstation.Server.Host.Components.IInstanceManager</a> interface, access the database with the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_controllers_1_1_api_controller.html#ab687e0fc0cb712708297c0c2b43ca849">Tgstation.Server.Host.Controllers.ApiController.DatabaseContext</a> property, and start jobs by injecting the Tgstation.Server.Host.Core.IJobManager interface.</p>
<h1><a class="anchor" id="arch_security"></a>
Security</h1>
<p>The authentication process begins in Tgstation.Server.Host.Controllers.HomeController.CreateToken . This is where users log in. They must supply their username and password via correct <a class="el" href="class_tgstation_1_1_server_1_1_api_1_1_api_headers.html">Tgstation.Server.Api.ApiHeaders</a> . The server first attempts to use these credentials to login to the system. If that succeeds it checks if the system user's UID is registered in the database. Failing either of the previous two, it tries to match the username and password to an entry in the database. If either of these methods succeeds the user is considered authenticated and a token is generated and sent back to the user. If the user is a system user, the context of their login is kept for the amount of time until their token expires + 1 minute.</p>
<p>The password hashing used for database users is the standard provided by ASP.Net Core. It utilizes PBKDF2 with HMAC-SHA256, 128-bit salt, 256-bit subkey, with 10000 iterations. Read about it here: <a href="https://andrewlock.net/exploring-the-asp-net-core-identity-passwordhasher/">https://andrewlock.net/exploring-the-asp-net-core-identity-passwordhasher/</a></p>
<p>When this token is supplied in the <code>Authorization</code> header of a subsequent request, it is first cryptographically validated that it was sent by the current server. The token contain's the user's ID, and, using it, the user's info is retrieved from the database and put into an <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_security_1_1_i_authentication_context.html">Tgstation.Server.Host.Security.IAuthenticationContext</a></p>
<p>Nearly all exposed controller actions are decorated with a Tgstation.Server.Host.Controllers.TgsAuthorizeAttribute . This attribute does 2 things. 1. It ensures the <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_security_1_1_i_authentication_context.html">Tgstation.Server.Host.Security.IAuthenticationContext</a> is valid for the request before running the action. 2. If it contains a permission flag specification, it will 403 the request if the user doesn't have one of the listed permissions.</p>
<h1><a class="anchor" id="arch_jobs"></a>
Jobs</h1>
<p>Long running operations create <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_models_1_1_job.html">Tgstation.Server.Host.Models.Job</a> objects which represent information about long running tasks. These objects can be queried to find out who started them, if they've been completed, canceled, who cancelled them, their error message if any, and get their progress percentage in some cases. The job will be created and supplied by the request that started it, but active/all jobs may also be queried.</p>
<h1><a class="anchor" id="arch_instance"></a>
Instances</h1>
<p>Instances exist in two forms: Their database metadata and their actual class. The class only exists if the instance is set to be <a class="el" href="class_tgstation_1_1_server_1_1_api_1_1_models_1_1_instance.html#a6f024aa440adbecbd80b053eb57badc2">Tgstation.Server.Api.Models.Instance.Online</a> . This is where all the actual server management code lives. A single instance is made up of individual components that work with each other through their intefaces</p>
<h2><a class="anchor" id="arch_ifactory"></a>
Instance Factory</h2>
<p>This is responsible for creating the components and weaving them into the final <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_components_1_1_instance.html">Tgstation.Server.Host.Components.Instance</a>. This happens automatically at server startup if an instance is configured to be online</p>
<h1><a class="anchor" id="arch_repository"></a>
Repository Manager</h1>
<p>The <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_repository_1_1_i_repository_manager.html">Tgstation.Server.Host.Components.Repository.IRepositoryManager</a> is the gatekeeper for cloning and accessing a <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_repository_1_1_i_repository.html">Tgstation.Server.Host.Components.Repository.IRepository</a> . Only one instance of a repository can be in use at a time (due to the single-threaded nature of libgit2), so the repository manager contains a semaphore wait queue which hands out the repository to only one client at a time. All repository operations (aside from cloning and deleting) are performed by the actual repository object. This includes fetching, hard resets, checkouts, synchronizing, etc. Most state put into the Tgstation.Server.Api.Models.Repository object is read directly from libgit2, exceptions being credentials and boolean settings.</p>
<h1><a class="anchor" id="arch_byond"></a>
Byond</h1>
<p>The BYOND installation setup is largely decoupled from the database. When a byond version is downloaded and installed by the Tgstation.Server.Host.Components.Byond.IByondManager it is extracted to a directory titled with it's version in the <code>BYOND</code> folder acompanied by a text document stating which version it is. Platform specific installation steps are handled by specific implementations of Tgstation.Server.Host.Components.Byond.IByondInstaller . When it comes time to use an executable, the manager provides a Tgstation.Server.Host.Components.Byond.IByondExecutableLock which contains absolute paths to the DreamMaker and DreamDaemon executables</p>
<h1><a class="anchor" id="arch_deployment"></a>
Compiler and Deployment</h1>
<p>The compilation process is a distinct series of steps:</p>
<ol type="1">
<li>Retrieve necessary information from the database in Tgstation.Server.Host.Components.IInstance.CompileProcess</li>
<li>Choose a uniquely named folder in the <code>Game</code> directory for deployment</li>
<li>Acquire a Tgstation.Server.Host.Components.Byond.IByondExecutableLock</li>
<li>Build the initial <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_models_1_1_compile_job.html">Tgstation.Server.Host.Models.CompileJob</a> object from available data (Byond version, Revision, directory, etc)</li>
<li>Announce the deployment through the chat bot system</li>
<li>Create and copy the repository to the <code>&lt;target folder&gt;/A</code> directory</li>
<li>Run the PreCompile hook</li>
<li>Auto detect or check if the configured .dme is present</li>
<li>Copy and apply static code modifications to the environment</li>
<li>Run DreamMaker on the .dme</li>
<li>Start a DreamDaemon instance to validate the DMAPI</li>
<li>Run the PostCompile hook</li>
<li>Copy <code>&lt;target folder&gt;/A</code> to <code>&lt;target folder&gt;/B</code></li>
<li>Symlink all <code>GameStaticFiles</code> to both the A and B directories</li>
<li>Commit the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_models_1_1_compile_job.html">Tgstation.Server.Host.Models.CompileJob</a> to the database</li>
</ol>
<p>If any of the above steps fail, the target directory is deleted and the deployment is considered a bust. If all went well, after the <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_models_1_1_job.html">Tgstation.Server.Host.Models.Job</a> completes the new CompileJob is loaded into the instance's <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_deployment_1_1_i_dmb_factory.html">Tgstation.Server.Host.Components.Deployment.IDmbFactory</a> .</p>
<p>The DmbFactory is where the <a class="el" href="architecture.html#arch_watchdog">Watchdog</a> gets the <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_deployment_1_1_i_dmb_provider.html">Tgstation.Server.Host.Components.Deployment.IDmbProvider</a> instances to run. Each CompileJob loaded into it is given a lock count. The latest CompileJob holds 1 lock and every DreamDaemon instance running that CompileJob holds another. Loading a new CompileJob releases the initial lock, and when all other locks are released the CompileJob's directory is deleted. Any directories in the <code>Game</code> folder not in use are also deleted when the Instance starts.</p>
<h1><a class="anchor" id="arch_chat"></a>
Chat Bot System</h1>
<p>The chat system is relatively simple. The Tgstation.Server.Host.Components.Chat.IChat manager creates <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_chat_1_1_providers_1_1_i_provider.html">Tgstation.Server.Host.Components.Chat.Providers.IProvider</a> objects which do the IRC/Discord/etc messaging.</p>
<p>The relationship between providers and the manager is a bit messy at the time of this writing (returned (im)mutable classes that map ids, to ids, to ids...) but it works.</p>
<p>The few built in chat commands query the necessary components to get their results. Custom chat commands are routed to the watchdog's active server and then the response is relayed back. The message information passed to DM code is documented in the <code>tgs_chat_user</code> datum in the DMAPI: <a href="https://github.com/tgstation/tgstation-server/blob/master/src/DMAPI/tgs.dm#L117">https://github.com/tgstation/tgstation-server/blob/master/src/DMAPI/tgs.dm#L117</a></p>
<h1><a class="anchor" id="arch_static"></a>
Static File Management</h1>
<p>This is largely just a remote file explorer. <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_controllers.html">Tgstation.Server.Host.Controllers</a> send requests to <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_static_files_1_1_i_configuration.html">Tgstation.Server.Host.Components.StaticFiles.IConfiguration</a> with an optional <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_security_1_1_i_system_identity.html">Tgstation.Server.Host.Security.ISystemIdentity</a> . If the identity is present <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_security_1_1_i_system_identity.html#a9b525a56c704424ce14e78edcb7d003e">Tgstation.Server.Host.Security.ISystemIdentity.RunImpersonated</a> is used to do the reading/writing, otherwise it is done as normal.</p>
<p>The <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_static_files_1_1_i_configuration.html">Tgstation.Server.Host.Components.StaticFiles.IConfiguration</a> object is also responsible for things like generating .dme modifications, symlinking static files during deployment, and running hook scripts.</p>
<h1><a class="anchor" id="arch_watchdog"></a>
Watchdog</h1>
<p>This is the core of tgstation-server, the component that starts, monitors, and updates DreamDaemon.</p>
<p>At it's core, the watchdog operates using a hot/cold server setup. At any given moment there are two DreamDaemon instances running, only one of which players can see. If anything bad happens to that server, it is killed and the inactive server has its port changed to catch all the connections. If any changes need to be made to the configuration (port, security, compile job), the inactive server is killed and immediately relaunched with the new configuration. Whenever the active server reboots, the two servers change ports so as to minimize load times.</p>
<p>General chat messages and verbose logs can be used to track watchdog state.</p>
<p>That's a high level view of things, now let's get to the nitty gritty.</p>
<h2><a class="anchor" id="arch_wd_launch"></a>
Launch</h2>
<p>First the most recent <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_deployment_1_1_i_dmb_provider.html">Tgstation.Server.Host.Components.Deployment.IDmbProvider</a> is retrieved from the <a class="el" href="interface_tgstation_1_1_server_1_1_host_1_1_components_1_1_deployment_1_1_i_dmb_factory.html">Tgstation.Server.Host.Components.Deployment.IDmbFactory</a> twice, adding 2 locks.</p>
<p>This is used to launch a Tgstation.Server.Host.Components.Watchdog.ISessionController via the watchdog's Tgstation.Server.Host.Components.Watchdog.ISessionControllerFactory in the <code>A</code> directory of dmb providers <a class="el" href="class_tgstation_1_1_server_1_1_host_1_1_models_1_1_compile_job.html">Tgstation.Server.Host.Models.CompileJob</a> . This will be designated the <code>Alpha</code> server.</p>
<p>Whenever DreamDaemon is launched by any part of the watchdog, we try to elevate its process priority to the equivalent of Windows' <code>Above Normal</code></p>
<p>10 seconds are allowed to pass, then the <code>Bravo</code> server is launched via the same method except in the <code>B</code> directory. We then wait for both servers to finish their initial startup lag and then designate <code>Alpha</code> as the <code>Active</code> server and pass it to the monitor. The active server will be told to close it's port on reboot</p>
<p>If the watchdog ever enters a failure state it can't recover from, it kills both servers and reruns this process to restart.</p>
<h2><a class="anchor" id="arch_wd_monitor"></a>
The Monitor</h2>
<p>The monitor is responsible for handling every <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_components_1_1_watchdog.html#acb2ccc2dc05d01ec3a6448d3d57155c9">Tgstation.Server.Host.Components.Watchdog.MonitorActivationReason</a> . It sleeps until one of these things happen. If multiple things happen at once, they are processed in their order of declaration.</p>
<p>The monitor maintains a Tgstation.Server.Host.Components.Watchdog.MonitorState which helps it make descisions on how to handle activation reasons. The Tgstation.Server.Host.Components.Watchdog.MonitorState.NextAction determines how multiple simultaneous events are handled in succession.</p>
<h3><a class="anchor" id="mar_activecrash"></a>
Active Server Crashed/Exited</h3>
<p>If there was a graceful shutdown scheduled, exit the watchdog</p>
<p>Otherwise, if the inactive server has critfailed or is still booting, restart the watchdog</p>
<p>Otherwise, try to set the inactive server's port to the active server port and swap their designations. Failing that, restart the watchdog.</p>
<p>Otherwise, attempt to reboot the once active now inactive server with the latest settings, failing that, mark it as critfailed.</p>
<p>Stop processing further activation reasons</p>
<h3><a class="anchor" id="mar_inactivecrash"></a>
Inactive Server Crashed/Exited</h3>
<p>Attempt to reboot the inactive server with the latest settings, failing that, mark it as critfailed.</p>
<h3><a class="anchor" id="mar_activereboot"></a>
Active Server Rebooted</h3>
<p>Generally, at this point, the active server's port has been closed (unless it isn't for some reason) by the DMAPI</p>
<p>If there was a graceful shutdown scheduled, exit the watchdog</p>
<p>Otherwise, if the inactive server has critfailed or is still booting, restart the watchdog</p>
<p>Otherwise, if the active server needs a new DMB, a graceful restart, or settings update, kill the active server</p>
<p>If the port isn't closed, exit this activation reason. We wanted to keep it open for a reason.</p>
<p>Try to set the inactive server's port to the active server port and swap their designations. Failing that, restart the watchdog.</p>
<p>Set the current active server to close it's port on reboot.</p>
<p>If we didnt kill the now inactive server and got here set it to NOT close it's port on reboot and try and set it's port to be the internal game port (The DMAPI and SessionController have a method for communicating a new port to open on even if it's closed)</p>
<p>Failing the above case, or if we killed the now inactive server attempt to reboot it with the latest settings and stop processing other activation reasons, failing that, mark it as critfailed</p>
<p>Otherwise, skip processing the Tgstation.Server.Host.Components.Watchdog.onitorActivationReason.InactiveServerRebooted</p>
<h3><a class="anchor" id="mar_inactivereboot"></a>
Inactive Server Rebooted</h3>
<p>Mark the inactive server as rebooting, tell it to NOT close it's port on reboot.</p>
<h3><a class="anchor" id="mar_inactivereboot"></a>
Inactive Server Rebooted</h3>
<p>Mark the inactive server as ready, tell it to close it's port on reboot.</p>
<h3><a class="anchor" id="mar_setting"></a>
New Dmb Available or Launch Settings Changed</h3>
<p>Attempt to reboot the inactive server with the latest settings, failing that, mark it as critfailed</p>
<h2><a class="anchor" id="arch_reattach"></a>
Reattaching</h2>
<p>When TGS reboots for an update or via admin command it keeps the child DreamDaemon processes alive and saves state information to regain control of them when it comes back online. The saved state is entered as the Tgstation.Server.Host.Models.WatchdogReattachInformation for the instance in the database.</p>
<p>When the instance comes online again it will automatically attempt to reattach if said information is present. The information is deleted as soon as it is loaded.</p>
<p>If both servers reattached, the montor starts</p>
<p>If the active server failed to reattach, the watchdog is restarted.</p>
<p>If only the inactive server failed to reattach, it is mocked with a Tgstation.Server.Host.Components.Watchdog.DeadSessionController. Which will immediately trigger Tgstation.Server.Host.Components.Watchdog.MonitorActivationReason.InactiveServerCrashed . Then the monitor starts</p>
<h2><a class="anchor" id="arch_comms"></a>
Communication</h2>
<p>TGS =&gt; DM communication is achieved by sending packets which invoke <code>/world/Topic()</code> and DM can respond to those in kind. Tgstation.Server.Host.Components.EventType and other command messages are communicated to the active server via this method.</p>
<p>DM =&gt; TGS communication was initially meant to use <code>world.Export()</code> to access a controller and route the request to the specific instance. Due an issue with inherited handles (<a href="https://github.com/tgstation/tgstation-server/issues/71">https://github.com/tgstation/tgstation-server/issues/71</a>) that was causing problems but went undiagnosed for a long time, this idea was scrapped. It will soon return to replace the current implementation, however (<a href="https://github.com/tgstation/tgstation-server/issues/668">https://github.com/tgstation/tgstation-server/issues/668</a>).</p>
<p>DM =&gt; TGS communication currently works like so:</p>
<ol type="1">
<li>DM writes json to a specific file given in the initial launch json then enters a timeout sleep loop</li>
<li>The Host watches for and reads the json</li>
<li>The command is processed via the Tgstation.Server.Host.Components.Interop.ICommHandler for the DreamDaemon instance</li>
<li>The response is sent as a topic</li>
<li>DM writes the topic response into a variable</li>
<li>The sleep loop breaks when it reads this variable and returns the result</li>
</ol>
<p>Communication is necessary for the watchdog to flow things smoothly from a game client perspective. But realistically, due to how it works, the only absolutely required message is server reboots so it is known when to apply updates.</p>
<h1><a class="anchor" id="arch_update"></a>
Host Update Process</h1>
<p>There are actually two processes involved in a proper TGS setup. The actual <a class="el" href="namespace_tgstation_1_1_server_1_1_host.html">Tgstation.Server.Host</a> .NET core application and the component that runs the <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_watchdog.html">Tgstation.Server.Host.Watchdog</a> (at this time, either <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_service.html">Tgstation.Server.Host.Service</a> or <a class="el" href="namespace_tgstation_1_1_server_1_1_host_1_1_console.html">Tgstation.Server.Host.Console</a>). The directory structure of the setup is like so:</p>
<p>/app_directory</p><ul>
<li>/lib<ul>
<li>/Default<ul>
<li>Initial <a class="el" href="namespace_tgstation_1_1_server_1_1_host.html">Tgstation.Server.Host</a> executable files</li>
</ul>
</li>
<li>Space for updates to be installed</li>
</ul>
</li>
<li>Host.Watchdog executable files</li>
</ul>
<p>The Host.Watchdog launches the Host with a designated path in the <code>/lib</code> folder. When the Host process wants to update, it extracts the new Host package to this directory and exits with code 1. The watchdog then attempts to rename the current <code>/lib/Default</code> directory to something unique, rename the update directory to <code>/lib/Default</code> and the launch the new Host process.</p>
<p>The Host.Watchdog serves an additional purpose of automatically restarting the the Host in the case of a fatal crash (which should never happen, but the additional layer of safety is nice). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
